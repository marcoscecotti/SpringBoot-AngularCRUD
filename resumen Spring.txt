Pasos para crear una página en Spring:

El controlador recibe la petición web, allí manda a llamar a un servicio que es el que ejecuta la lógica de la aplicación, usando el repositorio que es el
que se conecta con la base de datos y el repositorio usa el modelo para saber qué tipo de información va a traer o guardar.

Dependecias:
- Spring Boot DevTools
- Spring Web
- Lombok
- Thymeleaf
- Spring Data JPA
- MySQL Driver

Para agregar mas dependencias una vez ya creado el proyecto: pom.xml -> <dependencies> -> Click derecho -> Spring Boot Dependencies

Crear carpetas models, repositories, services, controllers

1- Crear modelos: Pasar del modelo fisico a codigo.
Ejemplo:
@Entity   -> Necesitamos que sea una entidad para manipularlo con la base de datos
@Table(name = "usuarios") -> Acá tenemmos que poner el mismo nombre que el de la tabla que tenemos en MySQL
@Data -> Crea el constructor vacío, getters y setters, toString, equals y hashCode
public class UsuarioModel implements Serializable{

	private static final long serialVersionUID = 1L;

	//Para el id:
	@Id
	@GeneratedValue(startegy = GenerationType.IDENTITY) -> ID autoincrementable
	@Column(unique=true, nullable=false)
	Long Id;

}
//Para cada atributo agregarle si acepta null o no.

2- Crear repositorios: Son interfaces que extienden de crudRepository (esto implementa la mayoría de los métodos que queremos usar con la base de datos, además le podemos agregar
los nuestros).
@Repository
public interface UsuarioRepository extends CrudRepository<UsuarioModel, Long -> Tipo de dato del Id de UsuarioModel> {
	// Agregar consultas personalizadas
	public abstract ArrayList<UsuarioModel> findByPrioridad(Integer prioridad); 
	// Esto ta terrible, usando la notación "findBy[atributo]" directamente nos devuelve todos los usuarios que cumplan con ese atributo, no tenemos que programarlo nosotros
}

3- Creamos los servicios: Creamos una clase y una implementación:

public interface UsuarioService {
	public List<UsuarioModel> obtenerUsuarios();
	public void guardar(UsuarioModel usuario);
	public Optional<UsuarioModel> obtenerPorId(Long id);
	public void eliminarUsuario(Long id);
	
}

@Service
public class UsuarioServiceImpl implements UsuarioService {

	//Para poder usar el repositorio creado, lo declaramos como una variable, pero antes ponemos:
	@Autowired -> Hace que no tengamos que instanciar al repositorio
	UsuarioRepository usuarioRepository;
	//Por ejemplo acá podemos crear un método:
	@Override
	@Transactional(readOnly = true) -> Hace una transacción sólo si es necesario, xq es de solo lectura. IMPORTAR DE SPRING, NO DE JAVAX. 
	public ArrayList<UsuarioModel> obtenerUsuarios() {
		return(ArrayList<UsuarioModel>) usuarioRepository.findAll()  -> Poniendo "usuarioRepository." ya nos salta todas las consultas posibles a la BD que implementa CrudRepository
	}

	//Para guardar un usuario:
	@Override
	@Transactional -> Hace un commit o un rollback, depende lo que corresponda
	public UsuarioModel guardarUsuario(UsuarioModel usuario) {   -> Si se pasa usuario sin Id, se crea uno nuevo. Si se lo pasa con Id, lo actualiza
		return usuarioRepository.save(usuario);              -> Devuelve un usuario creado CON EL ID
	}

	//Buscar por Id:
	@Override
	@Transactional(readOnly = true)
	public Optional<UsuarioModel> obtenerPorId(Long id){        -> Optional hace que si no existe el id, no se rompa todo
		return usuarioRepository.findById(id);
	}


	//Eliminar usuario por id:
	@Override
	@Transactional
	public boolean eliminarUsuario(Long id){
		try{
			usuarioRepository.deleteById(id);
			return true;
		}catch(Exception err){
			return false;
		}
	}
}


4- Creamos los controladores:
@RestController -> Le decimos que es un controlador
@RequestMapping("/usuario")  -> URL -> http://localhost:8080/usuario
@Slf4j -> Para poder acceder a la variable log
public class UsuarioController {
	@Autowired
	UsuarioService usuarioService;

	@GetMapping() -> Cuando llegue una petición tipo GET ejecute la función de abajo
	public ArrayList<UsuarioModel> obtenerUsuarios(){
		return usuarioService.obtenerUsuarios();
	}

	@PostMapping() -> Guardar datos
	public UsuarioModel guardarUsuario(@RequestBody UsuarioModel usuario){
		return this.usuarioService.guardarUsuario(usuario);
	}

	@GetMapping(path = "/{id}")  -> Se toma como parámetro el id según la url: http://localhost:8080/usuario/1  -> Obtiene el usuario con id=1
	public Optional<UsuarioModel> obtenerUsuarioPorId(@PathVariable("id") Long id) {
		return this.usuarioService.obtenerPorId(id);
	}

	@GetMapping("/qurey")	-> Esto junto con @RequestParam, usa la URL: http://localhost:8080/usuario/query?prioridad=5 -> Busca el usuario con prioridad 5
	public ArrayList<UsuarioModel> obtenerUsuarioPorPrioridad(@RequestParam("prioridad") Integer prioridad){
		return this.usuarioService.obtenerPorPrioridad(prioridad);
	}


	@DeleteMapping(path = "/{id}")
	public String eliminarPorId(@PathVariable("id" Long id) {
		boolean ok = this.usuarioService.eliminarUsuario(id);
		if(ok){
			return "Se elimino el usuario con id " + id;
		}else{
			return "No pudo eliminar el usuario con id " + id;
		}
	}
		

}

HASTA ACA ES SOLAMENTE PARA CREAR UN CRUD con MySQL

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Thymeleaf:
Agregamos en el HTML:
<html xmlns:th="http://www.thymeleaf.org" xmnls="http://www.w3.org/1999/xhtml"> -> El ultimo hace que thymeleaf no muestre un error -> Es opcional
// Si agregamos el w3, todas las etiquetas hay que cerrarlas con />
<p th:text=""></p>

Pasar datos al html desde el controlador:
@GetMapping("/")
public String inicio(Model model){
	var mensaje = "Hola mundo con Thymeleaf";
	model.addAttribute("mensaje",mensaje);
	return "index";                              -> Muestra la vista index.html
}

En el HTML:
<p th:text="${mensaje}"></p>                         -> Con "${VARAIBLE}" accedemos a la variable
Si es una clase, accedemos a los atributos de la siguiente forma:
<p th:text="${nombre_clase.atributo}"

Para agregar links:
<a th:href="@{/agregar}">Crear Usuario</a>

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Conexión a BD con MySQL:
En application.properties:
spring.datasource.url=jdbc:mysql://localhost/nombre_BD?useSSL=false&serverTimezone=UTC&allowPublicKeyRetrival=true
spring.datasource.username=root
spring.datasource.password=admin
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialect   ->   Buscar "dialecto version X de mysql"
spring.jpa.properties.hibernate.format_sql=true                    ->   Para mostrar las consultas por consola de manera formateada     -> Spring usa por defecto jpa con hibernate
logging.level.org.hibernate.SQL=DEBUG                              ->   Para mostrar el SQL
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE  ->   Mostrar los parámetros de la sentencia SQL -> Deshabilitar la de format para usar esta

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Lo único que cambia para agregar la parte visual es la clase del controlador, por lo tanto quedaría:

Para agregar un usuario:
En HTML:
<form th:action="@{/guardar}" method="post" th:object="{usuario}">     -> th:object="{usuario}" asocia el usuario pasado en /agregar al formulario
	<input type="hidden" name="idUsuario" th:field="*{idUsuario}"/> -> HAY QUE PONER ESTO SI O SI, SINO CUANDO ACTUALIZAMOS UN USUARIO SE CREA UNO NUEVO CON LOS MISMOS DATOS
	<label for="nombre">Nombre:</label>
	<input type="text" name="nombre" th:field="*{nombre}"/>        -> th:field="*{nombre}" atributo nombre del objeto usuario definido anteriormente
	//HACER LO MISMO PARA LOS OTROS CAMPOS: el email es de type=email y telefono type=tel
	<input type="submit" name="guardar" value="Guardar"/>
</form>

Para editar podemos hacer:
<a th:href="@{/editar/} + ${usuario.idUsuario}" />   -> Esto hace por ej. http://localhost/editar/1 para el ID=1

Creamos los controladores:
@RestController -> Le decimos que es un controlador
@RequestMapping("/usuario")  -> URL -> http://localhost:8080/usuario
@Slf4j -> Para poder acceder a la variable log
public class UsuarioController {
	@Autowired
	UsuarioService usuarioService;

	@GetMapping("/") -> Cuando llegue una petición tipo GET ejecute la función de abajo
	public String inicio(Model model) {
		var usuarios = usuarioService.obtenerUsuarios();
		model.addAttribute("usuarios",usuarios);
		return index;
	}
	
	// Cuando haga click en agregar, se va a redirigir a la vista http://localhost:8080/modificar
	// Le llamamos modificar ya que vimos que el método guardarUsuario agrega o actualiza dependiendo si el ID es nuevo o no.
	@GetMapping("/agregar")
	public String agregar(Usuario usuario) {
		return "modificar";
	}

	@PostMapping("/guardar")
	public String guardar(Usuario usuario){
		usuarioService.guardar(usuario);'
		return "redirect:/"
	}


	@GetMapping("/editar/{idUsuario}")
	public String editar(Usuario usuario, Model model) {      -> Spring automáticamente ya busca el id del usuario, asi que lo pasamos completo
		usuarioService.encontrarUsuario(usuario);
		model.addAttribute("usuario",usuario);
		return "modificar";
	}
	
}

https://code.visualstudio.com/docs/?dv=win

